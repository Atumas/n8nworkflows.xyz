Create AI YouTube Shorts from Telegram ideas with Gemini VEO 3

https://n8nworkflows.xyz/workflows/create-ai-youtube-shorts-from-telegram-ideas-with-gemini-veo-3-11617


# Create AI YouTube Shorts from Telegram ideas with Gemini VEO 3

## 1. Workflow Overview

**Workflow name:** *YouTube Shorts VEO Automation*  
**Provided title:** *Create AI YouTube Shorts from Telegram ideas with Gemini VEO 3*

This workflow turns a Telegram message (a “shorts idea”) into **four 8‑second vertical video clips** generated by **Gemini VEO 3**, uploads each clip to **Google Drive** (publicly accessible), then uses **Fal.ai’s ffmpeg merge API** to **combine the 4 clips into one final portrait video**, sends the final result back to Telegram, and optionally (currently disabled) uploads it to YouTube Shorts after human approval.

### 1.1 Trigger & Conversation Gate (Telegram)
- Entry via Telegram bot message.
- Ignores `/start` and processes any other text.
- Sends a “processing” warning to prevent concurrent user messages from interrupting the flow.

### 1.2 AI Prompt/Script Generation (OpenAI Agent + Structured Parser)
- An AI Agent (running on **OpenAI gpt-5.1**) expands the user idea into:
  - a script
  - four independent VEO prompts (prompt1–prompt4) with consistent element descriptions
  - title, description, hashtags
- The output is validated via a **Structured Output Parser** schema.

### 1.3 Human-in-the-loop: Script Confirmation
- Sends the script to Telegram and waits for “CONFIRM”.
- Only proceeds to video generation after confirmation.

### 1.4 Parallel Video Generation (Gemini VEO 3) + Drive Upload
- Generates 4 independent vertical clips (9:16).
- Uploads each to Google Drive and extracts public URLs.
- A small delay is used before generating clip #3 (to throttle / sequence).

### 1.5 Merge the Clips (Fal.ai ffmpeg merge)
- Sends the 4 Drive URLs to Fal’s merge endpoint.
- Polls Fal’s `status_url` until `COMPLETED`.
- Downloads the merged video from `response_url`.

### 1.6 Distribution & Optional Publishing
- Uploads merged video to Drive to obtain a shareable link.
- Sends final video back to Telegram with description + hashtags.
- Asks user if they want to post; if “POST”, it downloads again and would upload to YouTube (node is disabled).

---

## 2. Block-by-Block Analysis

### Block 2.1 — Telegram Trigger & Start Command Filter
**Overview:** Receives Telegram messages and routes `/start` away from the main generation flow.  
**Nodes involved:** `Telegram Trigger`, `If2`, `Send a text message8`

#### Node: Telegram Trigger
- **Type / role:** `n8n-nodes-base.telegramTrigger` — webhook-based entrypoint for Telegram updates.
- **Config choices:**
  - Updates: `message` only.
- **Inputs/outputs:** Entry node → outputs to `If2`.
- **Failure modes / edge cases:**
  - Telegram credential revoked or bot token invalid.
  - Webhook misconfigured in Telegram or n8n URL changes.
  - Non-text messages: `message.text` may be missing (expressions relying on it can fail downstream).

#### Node: If2
- **Type / role:** `n8n-nodes-base.if` — checks whether incoming text equals `/start`.
- **Config choices:**
  - Condition: `{{$json.message.text}} == "/start"`.
  - True branch: **empty** (no node connected).
  - False branch: proceeds to processing message + AI.
- **Edge cases:**
  - If `message.text` undefined (stickers/images), strict validation may error.

#### Node: Send a text message8
- **Type / role:** `n8n-nodes-base.telegram` — informs user that processing has started and warns not to send more messages.
- **Config choices:**
  - Text: `Hey {{ $json.message.from.first_name }}!...`
  - Chat ID: `{{ $('Telegram Trigger').item.json.message.chat.id }}`
- **Outputs:** to `AI Agent`.
- **Failure modes:**
  - Telegram rate limiting or blocked bot.
  - Chat ID expression fails if trigger payload differs.

**Sticky note coverage:** “## Trigger ##” and “## How It Works … Setup … Human in the Loop …” (applies conceptually to this entry section).

---

### Block 2.2 — AI Agent: Script + 4 Prompts + Metadata (Validated JSON)
**Overview:** Uses OpenAI chat model to generate a structured plan: script, four prompts, title/description/hashtags; schema validation ensures parseable JSON for downstream expressions.  
**Nodes involved:** `OpenAI Chat Model`, `Structured Output Parser`, `AI Agent`

#### Node: OpenAI Chat Model
- **Type / role:** `@n8n/n8n-nodes-langchain.lmChatOpenAi` — language model provider for the agent.
- **Config choices:**
  - Model: `gpt-5.1`
  - Timeout: `3600000` ms (1 hour), unusually high to tolerate long generations.
- **Connections:** Attached to `AI Agent` via `ai_languageModel`.
- **Failure modes:**
  - Invalid OpenAI credentials / quota exceeded.
  - Model name unavailable in account/region.
  - Long response times despite high timeout.

#### Node: Structured Output Parser
- **Type / role:** `@n8n/n8n-nodes-langchain.outputParserStructured` — enforces JSON schema shape.
- **Config choices:**
  - Schema example requiring:
    - `items[0].script`
    - `items[0].prompt1..prompt4`
    - `items[0].hashtags`, `description`, `title`
- **Connections:** Attached to `AI Agent` via `ai_outputParser`.
- **Failure modes:**
  - Model output not valid JSON → parser failure.
  - Fields missing or wrong type → downstream prompt expressions break.

#### Node: AI Agent
- **Type / role:** `@n8n/n8n-nodes-langchain.agent` — orchestrates LLM output with enforced format.
- **Config choices (interpreted):**
  - PromptType: “define” with a long instruction block:
    - generate 4 independent prompts for VEO (no shared context)
    - ensure consistent character/setting descriptions across prompts
    - limit dialogue to ~16–20 words per clip
    - output must be **valid JSON** exactly matching schema
  - Uses Telegram user text: `{{ $json.message.text }}`
  - `hasOutputParser: true`
- **Input/Output:**
  - Input: from `Send a text message8` (still includes original Telegram trigger JSON).
  - Output: `output.items[0].script/prompt1..prompt4/hashtags/description/title`
- **Failure modes / edge cases:**
  - If user message is empty/non-text, agent prompt still renders but idea is missing.
  - Overly long ideas may lead to output truncation → invalid JSON.
  - Inconsistent casing/keys can break references like `$('AI Agent').item.json.output.items[0].prompt1`.

---

### Block 2.3 — Human Approval: Send Script, Wait for CONFIRM
**Overview:** Sends the AI-generated script back to the user and pauses until they confirm; acts as a safety gate before generating videos.  
**Nodes involved:** `Send message and wait for response`, `If1`

#### Node: Send message and wait for response
- **Type / role:** `n8n-nodes-base.telegram` — operation `sendAndWait` (interactive step).
- **Config choices:**
  - Message includes: `{{ $json.output.items[0].script }}`
  - ResponseType: `freeText`
  - ChatId: from `Telegram Trigger`.
- **Input:** output of `AI Agent` (so `$json.output...` is available).
- **Output:** emits an item containing user response at `$json.data.text`.
- **Failure modes:**
  - If conversation state expires or Telegram cannot deliver.
  - If user replies with anything else, flow stops (no “false” connection from If1).

#### Node: If1
- **Type / role:** `n8n-nodes-base.if` — checks whether reply equals one of accepted variants.
- **Config choices:**
  - OR conditions on `{{$json.data.text}}` equals `Confirm`, `CONFIRM`, `confrim` (note misspelling).
- **Outputs:**
  - True branch triggers video generation nodes.
  - False branch is not connected (execution ends).
- **Edge cases:**
  - User replies “confirm” (lowercase) is **not accepted** (only `Confirm` and `CONFIRM` + typo).
  - Leading/trailing whitespace not handled.

---

### Block 2.4 — Video Generation (4 clips) + Upload + URL Labelling + Progress Messages
**Overview:** Generates four VEO clips (9:16), uploads each clip to a public Drive folder, stores each public URL in a normalized field, and sends Telegram status updates.  
**Nodes involved:** `Generate a video1`, `Upload video1`, `Label URL 1`, `Send a text message`; `Generate a video2`, `Upload video`, `Label URL 2`, `Send a text message2`; `Wait5`, `Generate a video3`, `Upload video3`, `Label URL 3`, `Send a text message3`; `Generate a video4`, `Upload video4`, `Label URL 4`, `Send a text message4`; `Merge`

#### Node: Generate a video1 / 2 / 3 / 4
- **Type / role:** `@n8n/n8n-nodes-langchain.googleGemini` — Gemini “video” resource generation (VEO).
- **Config choices:**
  - Model: `models/veo-3.1-fast-generate-preview`
  - Aspect ratio: `9:16`
  - Prompt mapping:
    - video1 uses `$('AI Agent').item.json.output.items[0].prompt1`
    - video2 uses prompt2, etc.
- **Outputs:** returns generated media + metadata including `fileName` used later by Drive upload.
- **Failure modes:**
  - Gemini/PaLM API key invalid, model access not enabled, or quota exceeded.
  - Prompt too long / policy refusal.
  - Generation latency/timeouts.

#### Node: Upload video1 / Upload video / Upload video3 / Upload video4
- **Type / role:** `n8n-nodes-base.googleDrive` — uploads each generated clip to Drive folder.
- **Config choices:**
  - File name: `{{$now.format('yyyyLLdd')}}{{ $json.fileName }}`
  - Drive: “My Drive”
  - Folder: `VEO VIDEOS` (ID `1VkLZo09_BmiR1z_OHsh27hwFVH6-voiZ`)
- **Outputs:** includes `webContentLink` used as public URL.
- **Critical requirement (from sticky note):**
  - The folder must be **public** so Fal can download the clips.
- **Failure modes:**
  - OAuth expired / insufficient permissions.
  - Folder not shared publicly → Fal merge will fail to fetch URLs.
  - Upload size limits or transient Google API errors.

#### Node: Label URL 1 / 2 / 3 / 4
- **Type / role:** `n8n-nodes-base.set` — renames output fields to stable keys.
- **Config choices:**
  - URL extraction: `={{ $json.webContentLink }}`
  - Field names:
    - `prompt(1)` for clip1 (note parentheses and lowercase)
    - `Prompt(2)`, `Prompt(3)`, `Prompt(4)` for others (note inconsistent casing)
- **Outputs:** passes forward only labelled values (plus existing fields unless set node is configured to keep all; here “options” empty, defaults apply).
- **Edge cases:**
  - Inconsistent key naming requires careful references later (the merge HTTP request uses exact keys).

#### Node: Send a text message / 2 / 3 / 4
- **Type / role:** `n8n-nodes-base.telegram` — progress notifications.
- **Config choices:** “Video 1/4 generated”, etc.
- **Edge cases:** Telegram rate limit; chat id expression reliance on Trigger node.

#### Node: Wait5
- **Type / role:** `n8n-nodes-base.wait` — delay before generating video3.
- **Config choices:**
  - 1.5 minutes
- **Role in flow:**
  - From `If1` true branch, video1, video2, video4 start immediately, while video3 starts after delay.
- **Edge cases:**
  - Concurrency: clips are generated in parallel except #3; can create uneven completion ordering.

#### Node: Merge
- **Type / role:** `n8n-nodes-base.merge` — combines 4 inputs by position.
- **Config choices:**
  - Mode: `combine`
  - CombineBy: `combineByPosition`
  - numberInputs: `4`
- **Inputs:** from `Label URL 1` (index0), `Label URL 2` (index1), `Label URL 3` (index2), `Label URL 4` (index3)
- **Output:** a single item containing all four URL fields.
- **Failure modes:**
  - If any branch fails, Merge may wait indefinitely or output incomplete data depending on execution behavior.
  - Combine-by-position assumes exactly one item in each branch.

**Sticky note coverage:** “## Video Generation ##” and “## Drive … folder needs to be public …”.

---

### Block 2.5 — Fal.ai Merge + Polling Loop + Download Merged Video
**Overview:** Sends the 4 public clip URLs to Fal’s ffmpeg merge service, polls job status until completed, then fetches the merged output.  
**Nodes involved:** `HTTP Request`, `HTTP Request1`, `If`, `Wait`, `HTTP Request2`, `Download a video`

#### Node: HTTP Request (Fal merge submit)
- **Type / role:** `n8n-nodes-base.httpRequest` — starts Fal merge job.
- **Config choices:**
  - POST `https://queue.fal.run/fal-ai/ffmpeg-api/merge-videos`
  - JSON body includes:
    - `video_urls`: `prompt(1)`, `Prompt(2)`, `Prompt(3)`, `Prompt(4)`
    - `resolution`: `"portrait_16_9"` (Fal-specific preset)
    - `target_fps`: `30`
  - Headers include Authorization in format: `Key <id>:<secret>` (as shown in workflow).
- **Outputs:** expected to return `status_url` for polling.
- **Failure modes:**
  - Invalid/expired Fal key → 401/403.
  - Fal cannot access Drive URLs → job fails later or returns error status.
  - Wrong resolution preset may error (Fal API changes).

#### Node: HTTP Request1 (Poll status)
- **Type / role:** HTTP GET/Request to `{{ $json.status_url }}`
- **Config choices:** same Authorization headers.
- **Outputs:** returns job fields including `status` and (when ready) `response_url`.
- **Failure modes:**
  - `status_url` missing if submit failed.
  - Fal queue delays; repeated polling required.

#### Node: If (status == COMPLETED)
- **Type / role:** `n8n-nodes-base.if`
- **Config choices:** `{{$json.status}} == "COMPLETED"`
- **Outputs:**
  - True → `HTTP Request2`
  - False → `Wait` then loops back to `HTTP Request1`
- **Edge cases:**
  - No handling for `"FAILED"` / `"CANCELLED"` statuses → will poll forever.

#### Node: Wait (poll delay)
- **Type / role:** `n8n-nodes-base.wait`
- **Config choices:** amount `30` (unit not specified in JSON; n8n typically defaults to seconds in this node UI depending on configuration—verify in editor).
- **Outputs:** back to `HTTP Request1`.

#### Node: HTTP Request2 (Fetch result)
- **Type / role:** HTTP request to `{{ $json.response_url }}`
- **Expected output:** includes something like `{ video: { url: ... } }` (as used next).
- **Failure modes:**
  - `response_url` not present even when completed (API mismatch).
  - Large response or temporary 5xx.

#### Node: Download a video
- **Type / role:** `@n8n/n8n-nodes-langchain.googleGemini` — downloads video from URL into binary/file object.
- **Config choices:**
  - Operation: `download`
  - URL: `{{ $json.video.url }}`
- **Outputs:** downloadable file payload + `fileName` used by Drive upload.
- **Failure modes:**
  - URL expired or not publicly reachable.
  - Download timeouts / file too large.

**Sticky note coverage:** “## Fal … Put in for api ‘Key (your api)’”.

---

### Block 2.6 — Save Final Video, Send to Telegram, Ask to Post
**Overview:** Uploads merged video to Drive, labels its public URL, sends video to Telegram with caption (description + hashtags), then waits for “POST” to optionally publish.  
**Nodes involved:** `Upload video2`, `Label URL `, `Send a video`, `Send message and wait for response1`, `If3`, `Download a video1`, `Upload a video` (disabled)

#### Node: Upload video2 (final merged video)
- **Type / role:** `n8n-nodes-base.googleDrive` — stores merged output in same Drive folder.
- **Config choices:** same naming pattern and folder as clip uploads.
- **Outputs:** `webContentLink` used as public distribution URL.

#### Node: Label URL 
- **Type / role:** `n8n-nodes-base.set` — stores final link as `Finished_Video`.
- **Config choices:** `Finished_Video = {{$json.webContentLink}}`
- **Output:** to `Send a video`.

#### Node: Send a video
- **Type / role:** `n8n-nodes-base.telegram` — sends the final merged video to user.
- **Config choices:**
  - Operation: `sendVideo`
  - File: `{{ $json["Finished_Video"] }}`
  - Caption: `{{ description }}\n{{ hashtags }}` pulled from `AI Agent` output
- **Edge cases:**
  - Telegram may re-encode / distort aspect ratio (noted later).
  - Large file might exceed Telegram limits.
  - Using a URL as `file` relies on Telegram supporting URL fetch; if not accessible publicly, send fails.

#### Node: Send message and wait for response1
- **Type / role:** Telegram `sendAndWait` — asks whether to post to socials.
- **Config choices:** expects “POST”.
- **Output:** user response at `$json.data.text`.

#### Node: If3
- **Type / role:** If user responded with POST (case variants).
- **Config choices:** OR conditions for `POST`, `post`, `Post`.
- **Output:** to `Download a video1`.

#### Node: Download a video1
- **Type / role:** Gemini download operation.
- **Config choices:**
  - URL: `{{ $('Label URL ').item.json.Finished_Video }}`
- **Purpose:** obtains a file payload suitable for YouTube upload node.
- **Failure modes:** same as other download.

#### Node: Upload a video (disabled)
- **Type / role:** `n8n-nodes-base.youTube` — upload to YouTube Shorts.
- **Config choices:**
  - Title: `{{ title } #shorts`
  - Description: `{{ description }} #shorts {{ hashtags }}`
  - Region: US
- **Disabled:** `true` — publishing will not happen unless enabled.
- **Failure modes if enabled:**
  - YouTube OAuth consent / refresh token issues.
  - Shorts compliance (vertical, under 60s; here ~32s total).
  - Duplicate titles or upload quota limits.

**Sticky note coverage:** “## Distribution”.

---

## 3. Summary Table

| Node Name | Node Type | Functional Role | Input Node(s) | Output Node(s) | Sticky Note |
|---|---|---|---|---|---|
| Telegram Trigger | telegramTrigger | Entry point from Telegram messages | — | If2 | ## Trigger ## |
| If2 | if | Filter `/start` command | Telegram Trigger | Send a text message8, AI Agent | ## Trigger ## |
| Send a text message8 | telegram | Notify user request is processing | If2 (false branch) | AI Agent | ## Trigger ## |
| OpenAI Chat Model | lmChatOpenAi | LLM provider for agent (gpt-5.1) | — (AI attachment) | AI Agent (ai_languageModel) |  |
| Structured Output Parser | outputParserStructured | Enforce JSON schema for agent output | — (AI attachment) | AI Agent (ai_outputParser) |  |
| AI Agent | agent | Generate script + 4 prompts + metadata as JSON | Send a text message8 | Send message and wait for response |  |
| Send message and wait for response | telegram (sendAndWait) | Human confirmation gate (“CONFIRM”) | AI Agent | If1 |  |
| If1 | if | Check confirmation response | Send message and wait for response | Generate a video1, Generate a video2, Wait5, Generate a video4 |  |
| Generate a video1 | googleGemini (video generate) | Generate clip #1 (VEO 3) | If1 | Upload video1; Send a text message | ## Video Generation ## |
| Upload video1 | googleDrive | Upload clip #1 to Drive | Generate a video1 | Label URL 1 | ## Drive\nThe folder you have the individual videos save to needs to be public. This is so fal can get the URLs and combine them. |
| Label URL 1 | set | Store clip1 URL as `prompt(1)` | Upload video1 | Merge | ## Drive\nThe folder you have the individual videos save to needs to be public. This is so fal can get the URLs and combine them. |
| Send a text message | telegram | Notify “Video 1/4 generated” | Generate a video1 | — | ## Video Generation ## |
| Generate a video2 | googleGemini (video generate) | Generate clip #2 | If1 | Upload video; Send a text message2 | ## Video Generation ## |
| Upload video | googleDrive | Upload clip #2 to Drive | Generate a video2 | Label URL 2 | ## Drive\nThe folder you have the individual videos save to needs to be public. This is so fal can get the URLs and combine them. |
| Label URL 2 | set | Store clip2 URL as `Prompt(2)` | Upload video | Merge | ## Drive\nThe folder you have the individual videos save to needs to be public. This is so fal can get the URLs and combine them. |
| Send a text message2 | telegram | Notify “Video 2/4 generated” | Generate a video2 | — | ## Video Generation ## |
| Wait5 | wait | Delay before generating clip #3 | If1 | Generate a video3 | ## Video Generation ## |
| Generate a video3 | googleGemini (video generate) | Generate clip #3 | Wait5 | Upload video3; Send a text message3 | ## Video Generation ## |
| Upload video3 | googleDrive | Upload clip #3 to Drive | Generate a video3 | Label URL 3 | ## Drive\nThe folder you have the individual videos save to needs to be public. This is so fal can get the URLs and combine them. |
| Label URL 3 | set | Store clip3 URL as `Prompt(3)` | Upload video3 | Merge | ## Drive\nThe folder you have the individual videos save to needs to be public. This is so fal can get the URLs and combine them. |
| Send a text message3 | telegram | Notify “Video 3/4 generated” | Generate a video3 | — | ## Video Generation ## |
| Generate a video4 | googleGemini (video generate) | Generate clip #4 | If1 | Upload video4; Send a text message4 | ## Video Generation ## |
| Upload video4 | googleDrive | Upload clip #4 to Drive | Generate a video4 | Label URL 4 | ## Drive\nThe folder you have the individual videos save to needs to be public. This is so fal can get the URLs and combine them. |
| Label URL 4 | set | Store clip4 URL as `Prompt(4)` | Upload video4 | Merge | ## Drive\nThe folder you have the individual videos save to needs to be public. This is so fal can get the URLs and combine them. |
| Send a text message4 | telegram | Notify “Video 4/4 generated” | Generate a video4 | — | ## Video Generation ## |
| Merge | merge | Combine four URL items into one | Label URL 1/2/3/4 | HTTP Request | ## Video Generation ## |
| HTTP Request | httpRequest | Submit Fal merge job | Merge | HTTP Request1 | ## Fal \nFal.AI configuration:\n\nFal is an AI platform and we will be using their ffmpeg video combiner. \n\nPut in for api \"Key (your api) |
| HTTP Request1 | httpRequest | Poll Fal `status_url` | HTTP Request; Wait | If | ## Fal \nFal.AI configuration:\n\nFal is an AI platform and we will be using their ffmpeg video combiner. \n\nPut in for api \"Key (your api) |
| If | if | If Fal status is COMPLETED | HTTP Request1 | HTTP Request2; Wait | ## Fal \nFal.AI configuration:\n\nFal is an AI platform and we will be using their ffmpeg video combiner. \n\nPut in for api \"Key (your api) |
| Wait | wait | Delay between Fal status polls | If (false) | HTTP Request1 | ## Fal \nFal.AI configuration:\n\nFal is an AI platform and we will be using their ffmpeg video combiner. \n\nPut in for api \"Key (your api) |
| HTTP Request2 | httpRequest | Fetch Fal merge result from `response_url` | If (true) | Download a video | ## Fal \nFal.AI configuration:\n\nFal is an AI platform and we will be using their ffmpeg video combiner. \n\nPut in for api \"Key (your api) |
| Download a video | googleGemini (video download) | Download merged video file | HTTP Request2 | Upload video2 | ## Distribution |
| Upload video2 | googleDrive | Upload merged video to Drive | Download a video | Label URL  | ## Distribution |
| Label URL  | set | Store final Drive URL as `Finished_Video` | Upload video2 | Send a video | ## Distribution |
| Send a video | telegram (sendVideo) | Send final merged video to Telegram | Label URL  | Send message and wait for response1 | ## Distribution |
| Send message and wait for response1 | telegram (sendAndWait) | Ask whether to post (“POST”) | Send a video | If3 | ## Distribution |
| If3 | if | Check user wants to post | Send message and wait for response1 | Download a video1 | ## Distribution |
| Download a video1 | googleGemini (video download) | Download final video for YouTube upload | If3 | Upload a video | ## Distribution |
| Upload a video | youTube (upload) | Upload to YouTube Shorts (disabled) | Download a video1 | — | ## Distribution |
| Sticky Note5 | stickyNote | Comment: Drive folder must be public | — | — | ## Drive\nThe folder you have the individual videos save to needs to be public. This is so fal can get the URLs and combine them. |
| Sticky Note | stickyNote | Comment: Fal API key format | — | — | ## Fal \nFal.AI configuration:\n\nFal is an AI platform and we will be using their ffmpeg video combiner. \n\nPut in for api \"Key (your api) |
| Sticky Note6 | stickyNote | Comment: Trigger section | — | — | ## Trigger ## |
| Sticky Note10 | stickyNote | Comment: Video generation section | — | — | ## Video Generation ## |
| Sticky Note11 | stickyNote | Comment: Distribution section | — | — | ## Distribution |
| Sticky Note12 | stickyNote | Comment: Overall explanation + setup | — | — | (See Section 5) |

---

## 4. Reproducing the Workflow from Scratch (Manual Build Steps)

1. **Create Telegram bot + credentials**
   1. In Telegram, create a bot with **BotFather** and obtain the token.
   2. In n8n, create **Telegram API** credentials using the bot token.

2. **Add Trigger**
   1. Create node **Telegram Trigger**.
   2. Set **Updates** = `message`.
   3. Select your Telegram credentials.
   4. Activate the node once the workflow is ready so Telegram webhook is registered.

3. **Add `/start` filter**
   1. Create node **If** named `If2`.
   2. Condition: `{{ $json.message.text }}` equals `/start`.
   3. Connect: `Telegram Trigger → If2`.
   4. Leave the **true** branch unconnected (or connect to a welcome response if desired).

4. **Send processing warning**
   1. Create **Telegram** node named `Send a text message8`.
   2. Operation: `Send Message`.
   3. Chat ID: `{{ $('Telegram Trigger').item.json.message.chat.id }}`
   4. Text: warning that request is being processed and not to send additional messages.
   5. Connect: `If2 (false) → Send a text message8`.

5. **Create OpenAI model + Agent + Output Parser**
   1. Create **OpenAI Chat Model** node.
      - Model: `gpt-5.1`
      - Timeout: `3600000` ms
      - Set OpenAI credentials.
   2. Create **Structured Output Parser** node with a JSON schema example containing:
      - `items[0].script`, `prompt1..prompt4`, `hashtags`, `description`, `title`.
   3. Create **AI Agent** node.
      - PromptType: “define”
      - Paste the long instruction block (ensure it demands valid JSON exactly).
      - Include the user idea: `{{ $json.message.text }}`
      - Enable output parser usage.
   4. Wire AI attachments:
      - Connect `OpenAI Chat Model` to `AI Agent` via **AI Language Model** connection.
      - Connect `Structured Output Parser` to `AI Agent` via **AI Output Parser** connection.
   5. Connect main flow: `Send a text message8 → AI Agent`.

6. **Human confirmation step**
   1. Create **Telegram** node `Send message and wait for response`.
      - Operation: `Send and Wait`
      - ChatId: `{{ $('Telegram Trigger').item.json.message.chat.id }}`
      - Message includes: `{{ $json.output.items[0].script }}`
      - Response type: `freeText`
   2. Connect: `AI Agent → Send message and wait for response`.
   3. Create **If** node `If1`:
      - Conditions OR: `{{ $json.data.text }}` equals `CONFIRM` (and any variants you want).
   4. Connect: `Send message and wait for response → If1`.

7. **Generate 4 videos with Gemini VEO**
   1. Create Gemini credentials in n8n: **Google Gemini(PaLM) API**.
   2. For each clip, create a **Google Gemini** node (resource `video`, operation generate) named:
      - `Generate a video1` with prompt `{{ $('AI Agent').item.json.output.items[0].prompt1 }}`
      - `Generate a video2` with prompt2
      - `Generate a video3` with prompt3
      - `Generate a video4` with prompt4
      - Model: `models/veo-3.1-fast-generate-preview`
      - Aspect ratio: `9:16`
   3. Add a **Wait** node `Wait5` (1.5 minutes) before `Generate a video3` if you want the same throttling.
   4. Connect from `If1 (true)` to:
      - `Generate a video1`
      - `Generate a video2`
      - `Generate a video4`
      - `Wait5 → Generate a video3`

8. **Upload each clip to Google Drive and label URLs**
   1. Create Google Drive OAuth2 credentials.
   2. Create a Drive folder (e.g., “VEO VIDEOS”) and set it to **publicly accessible** (at least “Anyone with the link can view”).
   3. For each generated clip:
      - Add **Google Drive** upload node (operation Upload) pointing to the public folder.
      - File name: `{{ $now.format('yyyyLLdd') }}{{ $json.fileName }}`
      - Connect: `Generate a videoN → Upload videoN`
      - Add a **Set** node to store `webContentLink` under a unique key:
        - clip1: `prompt(1)`
        - clip2: `Prompt(2)`
        - clip3: `Prompt(3)`
        - clip4: `Prompt(4)`
      - Connect: `Upload videoN → Label URL N`
   4. Add Telegram “progress” nodes after each generation (optional) connected from each `Generate a videoN`.

9. **Merge the 4 labelled URLs**
   1. Add a **Merge** node:
      - Mode: `Combine`
      - Combine by: `Position`
      - Number of inputs: `4`
   2. Connect:
      - `Label URL 1 → Merge (input 1)`
      - `Label URL 2 → Merge (input 2)`
      - `Label URL 3 → Merge (input 3)`
      - `Label URL 4 → Merge (input 4)`

10. **Fal merge request + polling**
   1. Add **HTTP Request** node (POST) to `https://queue.fal.run/fal-ai/ffmpeg-api/merge-videos`
      - JSON body with `video_urls` mapped to the four keys from Merge output
      - Headers:
        - `Authorization: Key YOUR_FAL_KEY`
        - `Content-Type: application/json`
   2. Add **HTTP Request** node to GET `{{ $json.status_url }}` (poll).
   3. Add **If** node checking `{{ $json.status }}` equals `COMPLETED`.
   4. Add **Wait** node (e.g., 30 seconds).
   5. Connect loop:
      - submit → poll → if completed?
      - if **no**: wait → poll
      - if **yes**: request `{{ $json.response_url }}`

11. **Download merged result and distribute**
   1. Add **Google Gemini** node `Download a video` (operation download):
      - URL: `{{ $json.video.url }}`
   2. Upload to Drive via **Google Drive** node `Upload video2` (same folder).
   3. Set `Finished_Video = {{ $json.webContentLink }}` via Set node `Label URL `.
   4. Send final video to Telegram:
      - Telegram node `Send a video` operation `sendVideo`
      - File: `{{ $json.Finished_Video }}`
      - Caption: `{{ $('AI Agent').item.json.output.items[0].description }}\n{{ $('AI Agent').item.json.output.items[0].hashtags }}`

12. **Optional “POST” approval and YouTube upload (disabled by default)**
   1. Add Telegram `sendAndWait` node asking user to respond “POST”.
   2. Add If node to check POST variants.
   3. Add Gemini “download” node to fetch the final video as a file payload.
   4. Add YouTube node “Upload a video”:
      - Title: `{{ title }} #shorts`
      - Description: `{{ description }} #shorts {{ hashtags }}`
      - Enable node only after setting YouTube OAuth2 credentials and confirming your posting policy.

---

## 5. General Notes & Resources

| Note Content | Context or Link |
|---|---|
| The Drive folder containing individual clips must be public so Fal can access the URLs and merge them. | Applies to all “Upload video(1–4)” steps and Fal merge. |
| Fal requires Authorization header formatted as `Key YOUR_API_KEY` (in this workflow it’s shown as `Key <id>:<secret>`). | Fal merge submit/poll/result HTTP Request nodes. |
| Human in the loop: workflow does not publish automatically; it requires manual confirmation (“CONFIRM”) and optional “POST”. | Overall design / safety gate before generation and publishing. |
| “The video sends distorted but will post fine; Telegram makes video fit a certain ratio.” | Telegram distribution behavior (re-encoding / aspect fit). |

disclaimer Le texte fourni provient exclusivement d’un workflow automatisé réalisé avec n8n, un outil d’intégration et d’automatisation. Ce traitement respecte strictement les politiques de contenu en vigueur et ne contient aucun élément illégal, offensant ou protégé. Toutes les données manipulées sont légales et publiques.